input {
  # stdin {
  #   type => 's3'
  # }

  s3 {
    type => 's3'
    bucket => 'logging.kdgm.nl'
    backup_to_bucket => 'backup.logging.kdgm.nl'
    delete => true
    region => 'eu-west-1'
    prefix => 'media.staging.kerkdienstgemist.nl/log/'
    debug => true
    sincedb_path => 'sincedb_s3'
    interval => 10
    credentials => 'logstash.s3'
  }
}

# filter {
#   s3_access_log {
#     recalculate_partial_content => true
#   }
#   mutate {
#     'rename' => ['@timestamp', 'received_at']
#   }
#   grok {
#     'match' => [ 'message', '%{ICECAST_ACCESS_LOG}' ]
#   }
#   # date {
#   #   'add_tag' => 's3_timestamp'
#   #   'match' => ['timestamp', 'dd/MMM/yyyy:HH:mm:ss Z']
#   # }
#   geoip {
#     'add_tag' => 'geoip'
#     'source' => 'clientip'
#   }
# }

#
# Alternative implementation of s3_access_log using grok and other standard filters
#
filter {
  if [type] == 's3' {
    mutate {
      'rename' => ['@timestamp', 'received_at']
      'rename' => ['message', 's3_message']
    }
    grok {
      'patterns_dir' => 'patterns'
      'match' => [ 's3_message', '%{S3_ACCESS_LOG}' ]
      'add_tag' => 's3_access_log'
    }
    if 's3_access_log' in [tags] {
      if 'REST.COPY.OBJECT_GET' == [operation] {
        # mutate {} or drop {}
        mutate {
          'replace' => [ 'request_uri', 'POST /%{key} HTTP/1.1', 'referrer', '"%{operation}"', 'bytes', '-', 'agent', '"-"', 'duration', '0' ]
        }
      }
      ruby { code => "event['requester'] && event['requester'] = event['requester'][0..9]" }
      ruby { code => "event['request_time_ms'] && event['duration'] = (event['request_time_ms'].to_f / 1000.0).round" }
      if [response] == '206' {
        ruby { code => "event['bytes'] = [ 128 * 1024 + 3 * event['request_time_ms'].to_i, event['bytes'].to_i ].min if ((event['bytes'].to_i*8)/event['request_time_ms'].to_i > 2000)" }
      }
      mutate {
        'add_field' => { 'message' => '%{clientip} - %{requester} [%{timestamp}] "%{request_uri}" %{response} %{bytes} %{referrer} %{agent} %{duration}' }
      }
    }
    # geoip {
    #   'add_tag' => 'geoip'
    #   'source' => 'clientip'
    # }
    fingerprint {
      method => 'MD5'
      key => '5d8d3ff21f3586c316ebd28ba8f36848' 
    }
  }
}

output {
  file {
    message_format => '%{message}'
    path => './output.log'
  }
  stdout {
    codec => rubydebug
  }
}

